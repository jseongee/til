## Core Data

- 데이터를 영구적으로 저장하기 위해 사용
- Object Graph 관리 도구(ORM)로, Swift 객체를 데이터베이스와 매핑
- Object ↔ ORM(Core Data) ↔ DataBase

<br />

### Core Data Stack 구성 요소

| 구성 요소 | 설명 |
| --- | --- |
| Persistent Store | 실제 데이터를 저장하는 저장소 |
| Object Model | Entity, Attribute 등 데이터 구조 정의 |
| Persistent Store Coordinator | Object ↔ Store 간의 데이터 변환 담당 |
| Managed Object Context | 객체를 생성하고 관리하는 역할 |
- Persistent Store (영구 저장소)
    - Atomic Store: 모든 데이터를 메모리에 로드하는 방식
    - Non-atomic Store: 파일에 저장, 필요한 부분만 메모리에 로드, SQLite가 기본값
<br />

### Core Data의 데이터 흐름
- Object ↔ Context
    - `create`: 새로운 데이터를 생성하면, 이 객체는 Context에 임시로 저장
        
        ```swift
        let newMemo = MemoEntity(context: mainContext)
        ```
        
    - `read`: 이미 저장된 데이터를 사용할 때도, Context를 통해 객체로 가져와 조작

- Context ↔ DataBase(Persistent Store)
    - `fetch`: DB에 저장된 데이터를 Context로 전달
        
        ```swift
        let request = MemoEntity.fetchRequest()
        let list = context.fetch(request)
        ```
        
    - `save`: Context의 변경사항을 DB에 영구 저장
        
        ```swift
        context.save()
        ```

<br />

### NSPersistentContainer

- Core Data Stack 초기화 역할
- 메인 스레드용 스레드: `.viewContext`

<br />

```swift
// CoreData != DB
// CoreData == ORM (DB 사용을 쉽게 도와주는 도구)
// 기본 저장소 타입은 SQLite

// 초기화: NSPersistentContainer
// 기본작업: NSManagedObjectContext
// 나머지 객체들은 자동으로 관리

// 기본 흐름:
// 스택 초기화(자동) -> 모델 구성(모델 편집기) -> Context에서 CRUD 수행

// 모델 구성 예시:
// Entity 추가 -> Attribute 설정 -> Custom Class 이름 지정
// -> Xcode가 자동으로 NSManagedObject 생성

// 새로운 데이터를 만들면 DB에 바로 저장되는게 아니라 Context에 임시로 저장됨
// DB에 저장하려면 Context를 저장해야 함
```

- 새로운 객체는 DB에 즉시 저장되지 않고, Context에 임시로 저장됨
- DB에 반영하려면 `context.save()` 호출 필요

<br />

### Singleton 패턴

- Type Property로 접근하고, 최초로 접근할 때 초기화
    
    ```swift
    static let shared = DataManager()
    ```
    
- 인스턴스를 하나만 가짐
    
    ```swift
    // 외부에서 생성하지 못하도록
    private init() {}
    ```
    
- 장점
    - 인스턴스를 하나만 생성 → 메모리 절약
    - 어디서든 접근 가능
- 단점
    - 전역 상태 공유 → 예측 어려운 사이드 이펙트
    - 싱글톤 객체가 너무 많은 기능을 제공하면 확장성이 떨어짐
    - Unit Test 어려움

<br />

### 일반적인 Insert

- 하나하나의 객체를 생성하고 컨텍스트에 저장
- 많은 객체를 한꺼번에 저장하면 메모리 사용량이 많아지고 느려짐
- 각 객체마다의 검증으로 인한 성능 저하

```swift
let memo = MemoEntity(context: mainContext)
for content in contents {
		memo.content = content
}
context.save()
```

<br />

### Batch Insert

- Context를 거치지 않고, 딕셔너리 형태로 DB에 직접 삽입 → 빠름 / 메모리 효율성 좋음
- 객체 검증 생략
- 이후 context에 바로 반영하고 싶으면 별도 fetch 필요

```swift
var dataList = [[String: Any]]()
for content in contents {
		dataList.append(["content": content])
}
let insertRequest = NSBatchInsertRequest(entityName: "Memo", objects: dataList)
context.execute(insertRequest)
```

<br />

---

<br />

## 🤔 Comment

- Notification을 통한 데이터 전달 복습 필요 ❕
