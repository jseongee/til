## GCD (Grand Center Dispatch)

- Queue ≠ Thread: 큐는 작업을 담는 리스트이고, 스레드는 실제 실행 단위
- Thread - Queue ← Code(WorkItem): 큐에 작업을 등록하면 스레드가 이를 실행
- `sync`, `async`는 큐에 Work Item을 추가하는 방식, 동기화 자체를 의미 X

<br />

### QoS (Quality of Service)

- 작업의 우선순위와 리소스 배분 정도를 설정

<br />

### 작업 취소 기능 구현

1. `DispatchWorkItem` 클래스를 이용해 작업 생성
2. `isCancelled` 속성을 직접 확인하여 작업 중단 처리

```swift
var currentWorkItem: DispatchWorkItem?
// Work Item 단독 실행 가능! 보통은 디스패치 큐에 추가하는 방식!

@IBAction func submitWorkItem(_ sender: Any) {
    currentWorkItem = DispatchWorkItem { [weak self] in
        for num in 0..<100 {
            // 실제로 취소 로직을 직접 구현해야 함
            if let item = self?.currentWorkItem, item.isCancelled {
                print("작업 취소")
                return
            }
            print(num, terminator: " ")
            Thread.sleep(forTimeInterval: 0.1)
        }
    }

    if let currentWorkItem {
        concurrentQueue.async(execute: currentWorkItem)
    }

    currentWorkItem?.notify(queue: .main) {
        print("Done")
    }
}

@IBAction func cancelWorkItem(_ sender: Any) {
    currentWorkItem?.cancel()
}
```

- 작업 내부에서 `isCancelled`를 확인해 직접 중단 로직 구현 필요
- `cancel()`은 작업을 중단하지 않고, `isCancelled` 플래그만 `true`로 설정

<br />

### Group Task 처리

- 여러 작업을 하나의 그룹으로 묶고, 완료 시점에 한번에 처리 가능

```swift
let group = DispatchGroup()

@IBAction func runAsGroup(_ sender: Any) {
    concurrentQueue.async(group: group) {
        for _ in 0..<10 {
            print("🍏", separator: "", terminator: "")
            Thread.sleep(forTimeInterval: 0.1)
        }
		}

    concurrentQueue.async(group: group) {
        for _ in 0..<10 {
            print("🍎", separator: "", terminator: "")
            Thread.sleep(forTimeInterval: 0.2)
        }
    }

    concurrentQueue.async(group: group) {
        for _ in 0..<10 {
            print("🍋", separator: "", terminator: "")
            Thread.sleep(forTimeInterval: 0.2)
        }
    }

    group.notify(queue: .main) {
        print("Done Group Task")
				// 예: 파싱 결과로 UI 업데이트
    }
}
```

<br />

## Network

### URL 구조와 구성 요소

```swift
let url = URL(string: "https://www.youtube.com/watch?v=ABCDEFG")!
```

- `scheme`: 통신 프로토콜 (예: `http`, `https`, `ftp`, `ssh`, …)
- `host`: 도메인 (예: `www.youtube.com`)
- `port`: 접속 포트 (예: `8080`)
- `path`: 리소스 위치 (예: `/watch`)
- `query`: 요청 파라미터 (예: `v=ABCDEFG`)

<br />

### 퍼센트 인코딩

- URL에 한글/공백/특수문자 포함시 사용

```swift
"한글쿼리".addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)
```

<br />

### 상태 코드와 서버 처리 방식

- 404 Not Found: URL이 잘못됐거나 존재하지 않는 데이터
- 200 OK: 요청 성공, 데이터 존재 여부는 응답 데이터로 판단

<br />

### URLSession 기본 구조

```swift
// URL로 요청(Request)을 보내고,
// 서버에서 응답(Response)이 오면 클로저(completionHandler) 호출
let task = URLSession.shared.dataTask(with: url) { data, response, error in
		// data: 서버에서 전달된 결과, 바이너리 데이터
		// response: 응답 정보 보통 상태 코드 확인할 때 필요

		// 1. 에러 확인
		// 2. 응답(response) -> HTTPURLResponse -> statusCode
		// 3. 데이터 존재 확인
		// 4. 데이터 파싱 (디코딩 등)
}

task.resume()
```

- URLSession 종류
    - Data Task: 아주 작은 바이너리/텍스트 데이터를 주고 받을 때, API 연동할 때
    - Upload/Download Task: 파일 전송, 백그라운드 전송 지원
    - Websocket Task: 채팅, 저지연 전송, TCP

<br />

### JSON 디코딩

- 서버가 `{}`형태로 JSON을 보낸다면, `Decodable` 프로토콜 추가 필수

```swift
struct Books: Decodable {
    let totalCount: Int
    let code: Int
    let message: String?
    let list: [Book]

    struct Book: Decodable {
        let id: Int
        let title: String
        let summary: String
        let storeLink: String
        let publicationDate: String
    }
}

JSONDecoder().decode(Books.self, from: dataFromServer)
```

<br />

### 전체 네트워크 처리 예시

```swift
var url = URL(string: "https://example.azurewebsites.net/books")!
url.append(queryItems: [URLQueryItem(name: "apiKey", value: "estkdtios2")])

let task = URLSession.shared.dataTask(with: url) { data, response, error in
    if let error {
	      print(error)
				return
    }

    guard let httpResponse = response as? HTTPURLResponse,
			    httpResponse.statusCode == 200,
			    let data else {
        return
    }

    do {
        let books = try JSONDecoder().decode(Books.self, from: data)
        if let str = books.list.first?.storeLink,
	         let url = URL(string: str) {
						print(url)
        }
    } catch {
        print(error)
    }
}

task.resume()
```

<br />

### 헤더에 정보 담아서 보내기

```swift
var urlRequest = URLRequest(url: url)
// key: "api-version", value: "2.0"
urlRequest.addValue("2.0", forHTTPHeaderField: "api-version")

let task = URLSession.shared.dataTask(with: urlRequest) {...}
task.resume()
```

<br />

## WebKit View

- 앱 내에서 웹 뷰 표시하기
- `WKWebView` 추가 → `URLRequest()` 만들기 → `load()` 호출

```swift
import UIKit
import WebKit

class LinkViewController: UIViewController {
    var url: URL?

    @IBOutlet weak var webView: WKWebView!

    override func viewDidLoad() {
        super.viewDidLoad()

        if let url {
            let request = URLRequest(url: url)
            webView.load(request)
        }
    }
}
```

- `Crash` 발생시, `Webkit.framework` 프로젝트에 추가

  <img width="750" src="https://github.com/user-attachments/assets/95f1cbf2-01e9-4a39-925a-7d374ed97745" />
